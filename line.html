<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */
 
body { font: 12px Arial;}
 
path { 

  fill: none;
}
 
.axis path,
.axis line {
	fill: none;
	stroke: grey;
	stroke-width: 1;
	shape-rendering: crispEdges;
}
.y.axis path{
	display: none; 
}
.axis .minor line {
  stroke: #777;
  stroke-dasharray: 2,2;
}
 
</style>
<body>
 
<!-- load the d3.js library -->	
<script src="http://d3js.org/d3.v3.min.js"></script>
 
<script>
 
// Set the dimensions of the canvas / graph
var	margin = {top: 30, right: 100, bottom: 100, left: 80},
	width = 800 - margin.left - margin.right,
	height = 400 - margin.top - margin.bottom;
var sector = ["Electricity", "Manufacturing","Transportation", "Other Fuel Combustion","Fugitive Emissions", "Industrial Processes", "Agriculture", "Waste", "Land-Use Change and Forestry", "Bunker Fuels"]

var svg_showing = false;
var	svg = d3.select("body")
		.append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
		.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
 
// Set the ranges
function line(year){
	var	x = d3.scale.linear().range([0, width]);
	var	y = d3.scale.linear().range([height, 0]);
	 
	// Define the axes
	var	xAxis = d3.svg.axis().scale(x)
		.orient("bottom").ticks(10).tickFormat(function(d,i){
            return sector[i];
        });
	 
	var	yAxis = d3.svg.axis().scale(y)
		.orient("left").ticks(6)
		.tickSize(width)
		.outerTickSize(0)
    .orient("right");
	 
	// Define the line
	var	valueline = d3.svg.line()
		.x(function(d) { return x(d.sector); })
		.y(function(d) { return y(d.amount); });
	    
	// Adds the svg canvas
	if(svg_showing == false){
		// var	svg = d3.select("body")
		// .append("svg")
		// 	.attr("width", width + margin.left + margin.right)
		// 	.attr("height", height + margin.top + margin.bottom)
		// .append("g")
		// 	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	 
	// Get the data
	d3.csv("line_data.csv", function(error, data) {
	  	if(error){
			console.log( error ) ;
		}

		data.forEach(function(d) {
			d.year = +d.year;
			d.sector = +d.sector;
			d.amount = +d.amount;
			
		});
	 
		// Scale the range of the data
		x.domain([d3.min(data, function(d) { return d.sector; }), d3.max(data, function(d) { return d.sector; })]);
		y.domain([0, d3.max(data, function(d) { return d.amount; })]);

		var dataNest = d3.nest()
        .key(function(d) {return d.year;})
        .entries(data);
	 
		// Add the valueline path.
		var opacity=[];
		var color=[];
		var stroke=[];
		for(i= 1990; i<2013;i++){
			if (i < year) {
				opacity.push(0.5);
				color.push("#BCBABE");
				stroke.push(1);
			};
			if (i == year) {
				opacity.push(1);
				color.push("#375E97");
				stroke.push(3);
			}
			if(i > year) {
				opacity.push(0);
				color.push("#375E97");
				stroke.push(2);
			}
		}

		console.log(opacity);
		console.log(dataNest);
		console.log(color);
		var i = 0;
		dataNest.forEach(function(d) {
	        svg.append("path")
	            .attr("class", "line")
	            .attr("d", valueline(d.values))
	            .attr("opacity", opacity[i])
	            .attr("stroke",color[i])
	            .attr("stroke-width",stroke[i]);

	            i++; 
    	});
	 
		// Add the X Axis
		svg.append("g")		
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis)
			.selectAll("text")
	  	.attr("y", 9)
	  	.attr("x", 9)
	  	.attr("dy", ".35em")
	  	.attr("transform", "rotate(30)")
	  	.style("text-anchor", "start");
	 
		// Add the Y Axis
		var gy= svg.append("g")		
			.attr("class", "y axis")
			.call(yAxis);

		gy.selectAll("g").filter(function(d) { return d; })
		    .classed("minor", true);

		gy.selectAll("text")
		    .attr("x", -40)
		    .attr("dy", -4);
			});

		svg_showing= true;
}
else{
	d3.selectAll("path.line").remove();
	d3.csv("line_data.csv", function(error, data) {
	  	if(error){
			console.log( error ) ;
		}

		data.forEach(function(d) {
			d.year = +d.year;
			d.sector = +d.sector;
			d.amount = +d.amount;
			
		});
	 
		// Scale the range of the data
		x.domain([d3.min(data, function(d) { return d.sector; }), d3.max(data, function(d) { return d.sector; })]);
		y.domain([0, d3.max(data, function(d) { return d.amount; })]);

		var dataNest = d3.nest()
        .key(function(d) {return d.year;})
        .entries(data);
	 
		// Add the valueline path.
		var opacity=[];
		var color=[];
		var stroke=[];
		for(i= 1990; i<2013;i++){
			if (i < year) {
				opacity.push(0.5);
				color.push("#BCBABE");
				stroke.push(1);
			};
			if (i == year) {
				opacity.push(1);
				color.push("#375E97");
				stroke.push(3);
			}
			if(i > year) {
				opacity.push(0);
				color.push("#375E97");
				stroke.push(3);
			}
		}

		console.log(opacity);
		console.log(dataNest);
		console.log(color);
		var i = 0;
		dataNest.forEach(function(d) {
	        svg.append("path")
	            .attr("class", "line")
	            .attr("d", valueline(d.values))
	            .attr("opacity", opacity[i])
	            .attr("stroke",color[i])
	            .attr("stroke-width",stroke[i]);

	            i++; 
    	});

   });
}

	 
}

// line(1990);
var i = 1990;
	setInterval(function() {
	line(i);
	i++;
},500);

 
</script>
</body>